<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Forms</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" type="text/css" href="../../yadadocs.css" />
</head>
<body class="article toc2 toc-left">
<!-- When editing this file, you must copy it in all other folders (without change) -->

<select id="navigator">
	<option>Choose chapter...</option>
	<option data-link="./index.html">Index</option>
	<option data-link="./newEclipseProject.html">Getting started</option>
	<option data-link="./examples/bookstoreTutorial.html">Bookstore tutorial</option>
	<option data-link="./internationalization.html">Internationalization</option>
	<option data-link="./database/pagination.html">Database pagination</option>
	<option data-link="./forms/overview.html">Forms</option>
	<option data-link="./ajax.html">Ajax</option>
	<option data-link="./ajaxModal.html">Ajax Modal</option>
	<option data-link="./datatables.html">DataTables</option>
	<option data-link="./emails.html">Sending Emails</option>
	<option data-link="./notificationModal.html">Notification Modal</option>
	<option data-link="./misc.html">Misc</option>
	<option data-link="./troubleshooting.html">Troubleshooting</option>
	<option data-link="./upgrade.html">Upgrade Yada Framework Version</option>
</select>
<script>
document.querySelector("#navigator").addEventListener("change", function (event) {
	const goup = location.href.lastIndexOf("/") - location.href.lastIndexOf("/en") > 3;
	const link = (goup?"../":"") + this.options[this.selectedIndex].getAttribute("data-link");
	if (link!=null) {
		document.location.href = link;
	}
});
</script>
<div id="header">
<h1>Forms</h1>
<div class="details">
<span id="revnumber">version 0.7.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_subsections">Subsections</a></li>
<li><a href="#_description">Description</a></li>
<li><a href="#_plain_forms">Plain Forms</a></li>
<li><a href="#_form_backing_beans">Form Backing Beans</a></li>
<li><a href="#_entity_backing_beans">Entity Backing Beans</a></li>
<li><a href="#_ajax_forms">Ajax Forms</a>
<ul class="sectlevel2">
<li><a href="#_postprocessing">Postprocessing</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Handling user-submitted data</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_subsections">Subsections</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="uploads.html">File Uploads</a></dt>
<dd>
<p>How to upload and handle files using forms</p>
</dd>
<dt class="hdlist1"><a href="fieldsComponents.html">Form Components</a></dt>
<dd>
<p>Enhanced input fields</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Forms are used to gather information from users. You could also use plain anchors with request attributes, but forms are way more convenient especially
for more than a couple of fields and when performing validation.</p>
</div>
<div class="paragraph">
<p>The more general kind of form has some input fields that are sent to the server in a POST and received from the @Controller as method parameters. This is a
<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller">standard Spring Web MVC feature</a> and quite straightforward to implement.</p>
</div>
<div class="paragraph">
<p>For more complicated forms you&#8217;d rather have a "form backing bean" holding all the input fields.
This allows the use of the Yada Form Fragments for quickly assembling the HTML of the form.</p>
</div>
<div class="paragraph">
<p>Creating a java object just to hold the form data might seem overkill when you already
have a database @Entity with the same exact fields. With a simple technique you can very easily use the same @Entity classes as form backing beans and save yourself
a lot of work.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_plain_forms">Plain Forms</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The standard plain forms don&#8217;t need much explanation: you have some HTML with input fields and a @Controller that receives those input fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="html" class="language-html hljs">&lt;form th:action="@{/addBook}"&gt;
        &lt;input name="bookTitle" th:value="${bookTitle}"&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Controller
public class BookController {
        @RequestMapping("/addBook")
        public String addBook(String bookTitle) {
                Book book = new Book(bookTitle);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above code doesn&#8217;t perform any validation but in a real-world example it should check at least that the title is not empty and go back to the user with an error message.
The error handling code would have to be added for any field. Writing it could be quite time-consuming if there are more than a couple of fields.
This is a possible solution for error handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="html" class="language-html hljs">&lt;form th:action="@{/addBook}"&gt;
        &lt;input name="bookTitle" th:value="${bookTitle}" th:classappend="${titleError}?'formError':''"&gt;
        &lt;div th:if="${titleError!=null}" th:text="${titleError}" class="formError"&gt;Title Error&lt;/div&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Controller
public class BookController {
        @RequestMapping("/addBook")
        public String addBook(String bookTitle, Model model) {
                if (bookTitle.trim().length()==0) {
                        model.addAttribute("titleError", "The book title can not be empty");
                        return "bookForm";
                }
                Book book = new Book(bookTitle);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_form_backing_beans">Form Backing Beans</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_entity_backing_beans">Entity Backing Beans</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When the form contains most of the fields that are defined in an existing @Entity it makes sense to use that @Entity as a backing bean.
Some may argue that exposing database classes on the front-end layer would compromise layer isolation, but we never experienced anything bad by doing this.</p>
</div>
<div class="paragraph">
<p>The general idea is that Spring can create an instance of a new @Entity or read it from the database before setting form values on it. The @Controller
method handling the form will receive a ready-populated @Entity where any database value has been overwritten by the form value.
This is very convenient because you just have to save the object and the form values will be persisted to the database.
Even more, you can write a single method to handle both addition and editing of @Entity instances, sharing the common code.</p>
</div>
<div class="paragraph">
<p>The trick is to add a @ModelAttribute to the @Controller, which is always called before Spring calls the final @RequestMapping method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="html" class="language-html hljs">&lt;form th:action="@{/addBook}" th:object="${book}"&gt;
        &lt;input type="hidden" name="bookId" value="*{id}"&gt;
        &lt;input th:field="*{bookTitle}"&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Controller
public class BookController {

        @ModelAttribute("book")
        public Book addBook(@RequestParam(value="bookId", required=false) Long id) {
                Book toEdit = null;
                Exception exception = null;
                if (id!=null) {
                        try {
                                toEdit = bookRepository.findOne(id);
                        } catch (Exception e) {
                                exception = e;
                        }
                        if (toEdit==null) {
                                log.error("Can't find Book with id={} - (creating new)", id, exception);
                        } else {
                                log.debug("Book {}-{} fetched from DB as ModelAttribute", id, toEdit.getTitle());
                        }
                }
                if (toEdit==null) {
                        toEdit = new Book();
                }
                return toEdit;
        }

        @RequestMapping("/addBook")
        public String addBook(Book book, Model model) {
                // Validation here
                ...
                bookRepository.save(book);</code></pre>
</div>
</div>
<div class="listingblock todo">
<div class="content">
<pre>test that the above code works</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s always better to use a specific name for the @Entity id, like <code>bookId</code> and not just <code>id</code>, so that you can handle different @Entity instances in the same @Controller.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ajax_forms">Ajax Forms</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To send a form via ajax you just need to add the <code>yadaAjax</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="html" class="language-html hljs">&lt;form class="yadaAjax" action="/subscribe"&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a form is added dynamically via custom javascript, you also need to call</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">yada.enableAjaxForms();</code></pre>
</div>
</div>
<div class="paragraph">
<p>after the change.</p>
</div>
<div class="paragraph">
<p>Any submit handler that needs to be invoked before form submission has to be listed as a SubmitHandler value:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>data-yadaSubmitHandler</code></th>
<th class="tableblock halign-left valign-top"><code>yada:submitHandler</code></th>
</tr>
</thead>
</table>
<div class="paragraph">
<p>Both the data- attribute version and the yada: dialect version take a comma-separated list of function names
to be called in order. Submission is aborted if any returns false and any following functions are skipped.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="html" class="language-html hljs">&lt;form class="yadaAjax" action="/subscribe" yada:submitHandler="validateInput"&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Submit handlers can be set on the form tag and on any submit button.
The "this" object is either the form or the clicked button, depending on where the tag has been placed.</p>
</div>
<div class="sect2">
<h3 id="_postprocessing">Postprocessing</h3>
<div class="paragraph">
<p>There are many options to handle the server response, like replacing page content or invoking some
handler. See <em>ref</em>`ajax:Ajax Links` for more details. For example, this form replaces a page element with the
returned html:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="html" class="language-html hljs">&lt;form class="yadaAjax" action="/subscribe" yada:updateOnSuccess="#someSection"&gt;</code></pre>
</div>
</div>
<div class="listingblock todo">
<div class="content">
<pre>all. Remember that button handlers receive the button itself: function editTaskFormHandler(responseText, responseHtml, form, button) {</pre>
</div>
</div>
<div class="paragraph">
<p>TO BE CONTINUED</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.7.0<br>
Last updated 2021-12-08 19:20:30 +0100
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>